## A. Улучшенный список

* Ограничение времени	1 секунда
* Ограничение памяти	64Mb
* Ввод:	  стандартный ввод или input.txt
* Вывод:	стандартный вывод или output.txt

Напишите класс, который является расширением стандартного класса list. Сделайте так, чтобы, помимо обычных атрибутов в нем присутствовали такие:

1) reversed (с коротким псевдонимом R), который содержит тот же список, но с элементами в обратном порядке.
2) first (с коротким псевдонимом F), который содержит первый элемент списка. Должна присутствовать возможность изменять этот атрибут (и вместе с ним должен меняться и сам список). Атрибут не обязан работать корректно, если список пустой.
3) last (с коротким псевдонимом L), который содержит последний элемент списка. Должна присутствовать возможность изменять этот атрибут (и вместе с ним должен меняться и сам список). Атрибут не обязан работать корректно, если список пустой.
4) size (с коротким псевдонимом S), который содержит размер списка. Должна присутствовать возможность изменять этот атрибут: при увеличении размера в конец должны добавляться значения None, а при уменьшении последние элементы должны удаляться.

Обратите внимание, что все перечисленные атрибуты не являются методами (см. пример). Однако их рекомендуется не хранить, а вычислять «на лету».

### Формат ввода:
Ваш код должен иметь такой вид:
```
import sys

...

ваши импорты и реализация

класс должен называться «ExtendedList»

...

exec(sys.stdin.read())
```
(Программа выполнит код, записанный во входном файле)

### Примечания
Указание: от стандартного класса list можно наследоваться

## B. Очень Важный Класс

* Ограничение времени	1 секунда
* Ограничение памяти	64Mb
* Ввод	стандартный ввод или input.txt
* Вывод	стандартный вывод или output.txt

Хакер Лёша нашёл уязвимость в известном сервисе. Он хочет построить вредоносную систему, почти не отличимую от старой, а потому хочет воспользоваться Самым Важным Классом взломанной системы. Беда в том, что доступа к коду класса нет, его можно только импортировать. Хакеры пишут на ассемблере и теряются, когда речь идет о высокоуровневых языках, поэтому вам придётся помочь Лёше.

Часть коварного плана, которую вам предстоит реализовать, состоит в том, чтобы взять Очень Важный Класс и сконструировать на его основе новый. Остальное мы сделаем за вас.

Вредоносные изменения, которые вам предстоит внести по сравнению с оригинальным классом:

Обернуть все методы в декоратор (он вам тоже неизвестен, но уже написан и ждёт своего часа)
При попытке получить атрибут класса, значение которого является числом, возвращаемое значение нужно умножить на два
Если значение атрибута – это контейнер, нужно вернуть контейнер такого же типа, но пустой (для простоты можно считать, что все типы-контейнеры инициализируются одинаково, например, пустой список можно создать с помощью **list()**). С определением того, что такое контейнер, вам поможет документация модуля **collections.abc**
Кстати, Лёша – вежливый хакер, поэтому он не изменяет никакие атрибуты/методы/etc класса, не входящие в публичный интерфейс (начинающиеся с символа '_')

Ваше решение не должно ничего выводить на экран, ваша задача – только определить **HackedClass**. Оно может начинаться примерно так:
```
from app import VeryImportantClass, decorator

class HackedClass(VeryImportantClass):
    ...
```
### Примечания
Для сдачи используйте компилятор make

## C. Глючный модуль

* Ограничение времени	1 секунда
* Ограничение памяти	64Mb
* Ввод	стандартный ввод или input.txt
* Вывод	стандартный вывод или output.txt

Предположим такую невозможную ситуацию: у вас есть модуль на python, который не работает. 
При попытке его импорта интерпретатор ругается на какое-то количество синтаксических ошибок и непонятных исключений. 
Но выход есть! 
Напишите функцию force_load, которая будет импортировать этот злосчастный модуль и выкидывать из него все строчки с ошибками.

Пусть на вход она принимает имя модуля, который лежит в той же директории, а возвращает словарь со всеми объектами, которые удалось без ошибок создать на этапе импорта. 
Например, есть модуль broken.py:
```
def foo(): 
    return 1 
 
refrigerator 
 
 
raise TypeError(’I can\’t type!’) 
 
def bar(): 
    return 2
```
Предположим, у нас уже есть функция force_load - попробуем ее использовать:
```
>>>> m = force_load(’broken’) 
>>>> m 
{ ’bar’: <function main.bar>, 
 ’foo’: <function main.foo>} 
>>>> m[’bar’]() 
2 
>>>> m[’foo’]() 
1
```

### Примечания
При выполнении задачи вам могут помочь функции exec, eval, compile (не обязательно все) и модули sys и traceback.
Пример как положить объекты из выполненного блока кода в словарик ldict:
```
ldict = {} 
exec(’’.join(lines), globals(), ldict)
```
Обратите внимание, что есть очень особенные исключения SyntaxError. Если программа часть исключений обрабатывает, а часть нет – дело скорее всего именно в них.
https://docs.python.org/3/library/exceptions.html#SyntaxError Если совсем непонятно, стоит посмотреть у объекта перехваченного исключения атрибут args, там вся необходимая наводящая информация.

## D. Контекстные менеджеры среднего звена

* Ограничение времени	1 секунда
* Ограничение памяти	64Mb
* Ввод	стандартный ввод или input.txt
* Вывод	стандартный вывод или output.txt

Чудесная штука – исключения. В комплекте же с контекстными менеджерами их возможности возрастают многократно.
Напишите несколько контекстных менеджеров для обработки исключений. 

**Глушитель исключений**
```
with supresser(type_one, ...): 
    do_smth()
```
перехватывает исключения заданых (и только заданных) типов и возвращает управление потоку. Исключение не пробрасывается дальше

**Переименователь исключений**
```
with retyper(type_from, type_to): 
    do_smth()
```
меняет тип исключения, оставляя неизменными содержимое ошибки (атрибут args) и трейсбек. Исключение пробрасывается дальше

**Дампер исключений**
```
with dumper(stream): 
    do_smth()
```
записывает в объект stream тело и трейсбек исключения в необычном порядке: сначала ошибка, потом трейсбек исключение пробрасывается дальше.
предполагается что у объекта stream обязательно должен быть метод write (для отладки можно использовать io.StringIO())

**Пример использования retyper**
```
> cat use_retyper.py 
import managers 
 
def foo(): 
    i = 1 / 0 
 
 
with managers.retyper(ZeroDivisionError, KeyError): 
    foo() 
> python3 use_retyper.py
```
выведет
```
Traceback (most recent call last): 
  File "/Users/veronikaiv/Desktop/managers.py", line 16, in retyper 
    yield 
  File "use_retyper.py", line 8, in <module> 
    foo() 
  File "use_retyper.py", line 4, in foo 
    i = 1 / 0 
ZeroDivisionError: division by zero 
 
During handling of the above exception, another exception occurred: 
 
Traceback (most recent call last): 
  File "use_retyper.py", line 8, in <module> 
    foo() 
 [censored] 
  File "use_retyper.py", line 8, in <module> 
    foo() 
  File "use_retyper.py", line 4, in foo 
    i = 1 / 0 
KeyError: ’division by zero’
```
**Пример использования supresser**
```
cat use_supresser.py 
import managers 
import sys 
 
def foo(): 
    a = {} 
    a[1] 
 
 
with managers.supresser(ValueError, KeyError): 
    foo() 
 
with managers.supresser(KeyError): 
    1 / 0 
 
> python3 use_supresser.py
```
выведет
```
Traceback (most recent call last): 
  File "use_supresser.py", line 13, in <module> 
    1 / 0 
ZeroDivisionError: division by zero
```
**Пример использования dumper**
```
> cat use_dumper.py 
import managers 
import sys 
 
def foo(): 
    i = 1 / 0 
 
 
with managers.dumper(sys.stderr): 
    foo() 
> python3 dumper.py
```
выведет
```
ZeroDivisionError: division by zero 
Traceback (most recent call last): 
  File "use_dumper.py", line 9, in <module> 
    foo() 
  File "use_dumper.py", line 5, in foo 
    i = 1 / 0 
ZeroDivisionError: division by zero
```
### Примечания
Вам может пригодиться упрощённый способ создания контекстных менеджеров https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager
Обратите внимание, что менеджер supress надо реализовывать самостоятельно.

